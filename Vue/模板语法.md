# 基础

## 1. 模板语法

Vue.js 使用基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。

底层实现：Vue 将模板编译成虚拟 DOM 渲染函数，结合响应系统，Vue 计算出最少要重新渲染多少组件，并把 DOM 操作次数减到最少。

### 1.1 插值

Vue 的模板插值有：文本插值和原始 HTML 插值两种方式。

#### 1.1.1 文本插值

Vue 的文本插值使用 Mustache 语法`{{ vlaue }}`。

```html
<span>Message: {{ msg }}</span>
```

Mustache 标签将会被替代为对应数据对象上`msg`属性的值。任何时候，只要绑定的数据对象上`msg`属性发生了改变，插值处的内容就会更新。

`v-once`指令：执行一次性插值，当数据改变时，插值处的内容不会更新。

```html
<!-- 这会影响到这个节点上的所有数据绑定 -->
<span v-once>{{ msg }}</span>
```

#### 1.1.2 原始 HTML 插值

双大括号会将数据解释为普通文本，当插值要输出 HTML 代码时，需要使用`v-html`指令。

```html
<!-- 输出普通文本 -->
<p>Using mustaches: {{ rawHtml }}</p>
<!-- 作为HTML代码渲染 -->
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

> <font color=red>Notice：</font>绝对不要对用户提供的内容使用 HTML 插值，因为站点上动态渲染的 HTML 很容易受到 XSS 攻击，所以最好只对可信内容使用 HTML 插值。

Mustache 语法不能作用在 HTML 特有属性上，这个时候可以使用`v-bind`指令：

```html
<!-- 将ID设为对应对象上的dynamicId属性值 -->
<div v-bind:id="dynamicId"></div>
```

对于布尔特性，`v-bind`指令绑定的特性值为`null`、`undefined`、`false`时，那么渲染的时候，不会渲染对应的 HTML 特性。

#### 1.1.3 JS 表达式

Vue.js 支持模板中的插值使用 JS 表达式（每个插值都只能包含单个表达式）。

```html
<!-- 它们在所属 Vue 实例的数据作用域下作为 JS 被解析 -->
{{ number + 1 }}
{{ ok ？ 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div v-bind:id="'list' + id"></div>
```

> <font color=orange>Note：</font>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单（如`Math`和`Date`），访问不到用户定义的全局变量。

### 1.2 指令

指令是带有`v-`前缀的特殊特性。指令特性的值预期是单个 JS 表达式（`v-for`例外）。

指令的职责：当表达式的值改变，将其产生的连带影响，响应式地作用于 DOM。

#### 1.2.1 参数

一些指令能接受一个参数，在指令名后以冒号(`:`)表示。

```html
<a v-bind:href="url">...</a>
```

#### 1.2.2 动态参数

v2.6.0 开始，可以用方括号括起来的 JS 表达式作为一个指令的参数：

```html
<a v-on:[eventName]="doSomething">...</a>
```

**对参数表达式的约束：**

1. 回避大写键名。

   ```html
   <!-- 在DOM中使用模板时这段代码会被转换为v-bind:[someattr] -->
   <a v-bind:[someAttr]="value"> ... </a>
   ```

2. 使用没有空格或引号的表达式。

   ```html
   <!-- 这会触发一个编译警告 -->
   <a v-bind:['foo' + bar]="value"> ... </a>
   ```

#### 1.2.3 修饰符

修饰符是以半角句号(`.`)指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

```html
<!-- .prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault() -->
<form v-on:submit.prevent="onSubmit">...</form>
```

### 1.3 缩写

对于一些频繁用到的指令来说，使用`v-`前缀会比较繁琐。同时在构建 Vue 管理所有模板的 SPA 时，这个前缀没那么重要。因此 Vue 为`v-bind`和`v-on`这两个最常用的指令提供了简写。

#### 1.3.1 `v-bind`缩写

```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>
<!-- 缩写 -->
<a :href="url">...</a>
```

#### 1.3.2 `v-on`缩写

```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>
<!-- 缩写 -->
<a @click="doSomething">...</a>
```

---

## 2. 计算属性和侦听器

### 2.1 计算属性

虽然模板内嵌入 JS 表达式是被允许的，但模板中放入太多的复杂逻辑会让模板过重且难以维护。所以对于任何复杂逻辑，都应当使用计算属性。

```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```javascript
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

#### 2.1.1 计算属性缓存 vs 方法

可以通过在表达式中调用方法，达到和上面一样的效果：

```html
<p>Reversed message: "{{ reversedMsg() }}"</p>
```

```javascript
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

虽然2种方式最终结果完全相同，但它们的缓存方式不同：

- 计算属性基于它们的响应式依赖进行缓存，只在相关响应式依赖发生改变时它们才会重新求值。如果相关响应式依赖未发生改变，但触发了重新渲染，不会再次执行计算属性的函数。
- 每当触发重新渲染，调用方法总会再次执行函数。

#### 2.1.2 计算属性 vs 侦听属性

Vue 提供了**侦听属性**来观察和响应 Vue 实例上的数据变动。

```html
<div id="demo">{{ fullName }}</div>
```

```javascript
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```

这时候，代码是命令式且重复的。而使用计算属性，代码不会那么冗余：

```javascript
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

#### 2.1.3 计算属性的 setter

计算属性默认只有 getter，必要时也可以提供 setter：

```javascript
computed: {
  fullName: {
    get: function() {
      return `${this.firstName} ${this.lastName}`
    },
    set: function(newValue) {
      let names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// 在控制台运行 vm.fullName = 'John Doe' 时，setter 被调用
// vm.firstName 和 vm.lastName 会相应地更新
```

### 2.2 侦听器

当需要数据变化时执行异步或开销较大的操作时，使用侦听器是最有用的。

```html
<div id="watch-example">
  <p>
    Ask a yes/no question:
    <input v-model="question">
  </p>
  <p>{{ answer }}</p>
</div>
<!-- AJAX 库和通用工具的生态已够丰富，Vue 核心代码没有重复提供这些功能 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: { // 使用侦听器限制访问频率
    question: function(newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing ...'
      this.debouncedGetAnswer()
    }
  },
  created: function() {
    // _.debounce 是一个通过Lodash限制操作频率的函数
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer: function() {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Questions usually contain a question mark. ;-)'
        return
      }
      this.answer = 'Thinking ...'
      var vm = this
      anxios.get('https://yesno.wtf/api')
      	.then(function() {
          vm.answer = _.capitalize(response.data.answer)
      	}).catch(function(error) {
          vm.answer = 'Error! Could not reach the API. ' + error
        })
    }
  }
})
</script>
```

---

## 3. Class 与 Style 绑定

操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 `v-bind` 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。

### 3.1 绑定 HTML Class

#### 3.1.1 对象语法

通过传给`v-bind:class`一个对象来动态地切换 class：

```html
<div v-bind:class="{ active: isActive }"></div>
<!-- active这个class存在与否取决于数据属性isActive的truthiness -->
```

`v-bind:class`也可以与普通的 class 属性共存。

```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
<!-- 当hasError=flase, isActice=true 这个div的class="static active" -->
<!-- 当hasError=true, isActice=false 这个div的class="static text-danger" -->
```

绑定的数据对象不必内联定义在模板里。

```html
<div v-bind:class="classObj"></div>
```

```javascript
data: {
  classObj: {
    active: true,
    'text-danger': false
  }
},
computed: {
  classObject: function() {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

#### 3.1.2 数组语法

通过把一个数组传给`v-bind:class`来应用一个 class 列表：

```html
<div v-bin:class="[activeClass, errorClass]"></div>
```

```javascript
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

通过使用三元表达式根据条件切换列表中的 class：

```html
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```

在数组语法中也可以使用对象：

```html
<div v-bind:class="[{active: isActive}, errorClass]"></div>
```

#### ❤3.1.3 用在组件上



### 3.2 绑定内联样式

#### 3.2.1 对象语法

`v-bind:style`的对象语法看着像 CSS，但其实是一个 JS 对象。CSS 属性名可以用**驼峰式**或**短横线分隔**来命名。

```html
<div v-bind:style="{ color: activeColor, font-size: fontSize + 'px' }"></div>
```

```javascript
data: {
  activeColor: 'red',
  fontSize: 30
}
```

将样式直接绑定到一个样式对象，会让模板更清晰：

```html
<div v-bind:style="styleObj"></div>
```

```javascript
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
```

对象语法常常结合返回对象的计算属性使用。

#### 3.2.2 数组语法

`v-bind:style`的数组语法可以将多个样式对象应用到同一个元素上：

```html
<div v-bind:stlye="[baseStyles, overridingStyles]"></div>
```

#### 3.2.3 自动添加前缀

当`v-bind:style`使用需要添加浏览器引擎前缀的 CSS 属性时，Vue 会自动侦测并添加响应的前缀。

#### 3.2.4 多重值

v2.3.0+支持为`style`绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值。

```html
<div :style="{ display:['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

这样只会渲染数组中最后一个被浏览器支持的值。

---

## 4. 条件渲染

### 4.1 v-if

`v-if`指令用于条件性地渲染一块内容，这块内容只会在指令的表达式返回 truthy 值的时候被渲染。

```html
<h1 v-if="awesome">Vue is awesome</h1>
```

#### 在 template 元素上使用 v-if 条件渲染分组

因为`v-if`是一个指令，所以必须将它添加到一个元素上。但如果想切换多个元素，可以把一个`<template>`元素当做不可见的包裹元素，并在杀昂面使用`v-if`。最终的渲染结果不会包含`<template>`元素。

```html
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```

### 4.2 v-else

可以用`v-else`指令来表示`v-if`的”else 块“：

```html
<div v-if="Math.random() > 0.5">Now you see me</div>
<div v-else>Now you don't<div>
```

`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。

### 4.3 v-else-if

> v 2.1.0 新增

`v-else-if`充当`v-if`的”else if“块，可以连用：

```html
<div v-if="type === 'A'"> A </div>
<div v-else-if="type === 'B'"> B </div>
<div v-else-if="type === 'C'"> C </div>
<div v-else> Not A/B/C </div>
```

它也必须紧跟在带`v-if`或`v-else-if`的元素之后。

#### 用 key 管理可复用的元素

用`key`管理可复用元素的好处是：

- Vue 会更高效地渲染元素，让 Vue 变得非常快。

- 条件切换中，只切换不同的地方。

  ```html
  <template v-if="loginType === 'username'">
    <label>Username</label>
    <input placeholder="Enter your username">
  </template>
  <template v-else>
    <label>Email</label>
    <input placeholder="Enter your email address">
  </template>
  ```

  在上面的代码中切换`loginType`不会清楚用户已经输入的内容，因为两个模板使用了相同的元素怒，`<input>`不会被替换掉，仅仅是替换的它的`placeholder`。

  `<label>`标签仍会被高效复用，因为它们没有添加`key`属性

### 4.4 v-show

另一个用于根据条件展示元素的选项是`v-show`指令。

```html
<h1 v-show="ok">Hello~</h1>
```

带有`v-show`的元素始终会被渲染并保留在 DOM 中，只是显示和隐藏的问题。`v-show`只是简单地切换元素 CSS 的`display`属性值。

> <font color=red>Notive：</font>`v-show`不支持`template`元素，也不支持`v-else`。

### 4.5 v-if vs v-show

- `v-if`：

  真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当的被撤销和重建；

  它是**惰性的**，如果在初始渲染时条件为假，则什么也不做，直至条件第一次为真时才会开始渲染条件块。

  正因为它会对 DOM 树进行插入和移除的操作，因此它的开销较大。

- `v-show`：

  不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

  由于元素总是会被渲染，因此它的初始渲染开销较大。

---

## 5. 列表渲染

### 5.1 用 v-for 把一个数组对应为一组元素

可以用`v-for`指令基于一个数组来渲染一个列表。`v-for`指令需要使用`item in items`形式的特殊语法，其中`items`是源数据数组，`item`是被遍历的数组元素的**别名**。

```html
<ul id="example-1">
  <li v-for="item in items">
    {{ item.message }}
  </li>
</ul>
```

```javascript
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

 在 `v-for` 块中，可以访问所有父作用域的属性。`v-for` 还支持一个可选的第二个参数，即当前项的索引。

```html
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```

```javascript
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

也可以用`of`替代`in`作为分隔符，因为它更接近 JS 迭代器的语法。

### 5.2 在 v-for 里使用对象

可以用`v-for`来遍历一个对象的属性。

```html
<ul id="v-for-object" class="demo">
  <li v-for="vlaue in object">
    {{ value }}
  </li>
</ul>
```

```javascript
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
```

还可以用第三个参数作为索引：

```html
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }} : {{ value }}
</div>
```

> <font color=orange>Notice：</font>在遍历对象时，会按`Object.keys()`的结果遍历，但是不能保证它的结果在不同的 JS 引擎下都一致。

### 5.3 维护状态

当 Vue 正在更新使用`v-for`渲染的元素列表时，它默认使用”就地更新“的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并确保他们在每个索引位置正确渲染。

这个默认的模式是高效的，但是==只适用于不依赖子组件状态或临时 DOM 状态== (例如：表单输入值) ==的列表渲染输出==。

为了给 Vue 一个提示，让它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 `key` 属性：

```html
<div v-for="item in items" v-bind:key="item.id">
  <!-- content -->
</div>
```

尽可能在使用`v-for`时，提供`key`属性，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为来获取性能上的提升。它是 Vue 识别节点的一个通用机制，`key`并不是只与`v-for`特别关联。

### 5.4 数组更新检测

#### 5.4.1 变异方法

Vue 将被侦听的数组的**变异方法**进行了包裹，所以它们也将会触发视图更新。被包裹过的方法包括：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

#### 5.4.2 替换数组

变异方法会改变调用了这些方法的原始数组。相比之下，也有非变异方法，它们不会改变原始数组，而==总是返回一个新数组==（如 `filter()`、`concat()` 和 `slice()` ）。当使用非变异方法时，可以用新数组替换旧数组：

```javascript
example.items = example1.items.filter(function(item) {
  return item.message.match(/Foo/)
})
```

> <font color=red>Announcements：</font>
>
> 由于 JS 的限制，Vue 不能检测以下数组的变动：
>
> 1. 利用索引直接设置一个数组项时。
>
>    解决这个问题有两种方式：
>
>    - 通过`Vue.set()`方法，或者`Array.$set()`实例方法，它是全局方法`Vue.set`的一个别名。
>    - 通过`Array.prototype.splice()`方法。
>
> 2. 修改数组的长度时。
>
>    解决这个方法可以使用`splice()`。

### 5.5 对象变更检测注意事项

由于 JS 的限制，Vue 不能检测对象属性的添加或删除，对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性，但可以用`Vue.set(object, propertyName, value)`或`vm.$set`方法向嵌套对象添加响应式属性。

有时可能需要为已有对象赋值多个新属性，为了能响应式， 最好这样：

```javascript
vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
```

### 5.6 显示过滤 / 排序后的结果

有时，想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。在这种情况下可以创建一个计算属性来返回过滤或排序后的数组。



