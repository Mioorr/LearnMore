# 基础

## 1. 模板语法

Vue.js 使用基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。

底层实现：Vue 将模板编译成虚拟 DOM 渲染函数，结合响应系统，Vue 计算出最少要重新渲染多少组件，并把 DOM 操作次数减到最少。

### 1.1 插值

Vue 的模板插值有：文本插值和原始 HTML 插值两种方式。

#### 1.1.1 文本插值

Vue 的文本插值使用 Mustache 语法`{{ vlaue }}`。

```html
<span>Message: {{ msg }}</span>
```

Mustache 标签将会被替代为对应数据对象上`msg`属性的值。任何时候，只要绑定的数据对象上`msg`属性发生了改变，插值处的内容就会更新。

`v-once`指令：执行一次性插值，当数据改变时，插值处的内容不会更新。

```html
<!-- 这会影响到这个节点上的所有数据绑定 -->
<span v-once>{{ msg }}</span>
```

#### 1.1.2 原始 HTML 插值

双大括号会将数据解释为普通文本，当插值要输出 HTML 代码时，需要使用`v-html`指令。

```html
<!-- 输出普通文本 -->
<p>Using mustaches: {{ rawHtml }}</p>
<!-- 作为HTML代码渲染 -->
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

> <font color=red>Notice：</font>绝对不要对用户提供的内容使用 HTML 插值，因为站点上动态渲染的 HTML 很容易受到 XSS 攻击，所以最好只对可信内容使用 HTML 插值。

Mustache 语法不能作用在 HTML 特有属性上，这个时候可以使用`v-bind`指令：

```html
<!-- 将ID设为对应对象上的dynamicId属性值 -->
<div v-bind:id="dynamicId"></div>
```

对于布尔特性，`v-bind`指令绑定的特性值为`null`、`undefined`、`false`时，那么渲染的时候，不会渲染对应的 HTML 特性。

#### 1.1.3 JS 表达式

Vue.js 支持模板中的插值使用 JS 表达式（每个插值都只能包含单个表达式）。

```html
<!-- 它们在所属 Vue 实例的数据作用域下作为 JS 被解析 -->
{{ number + 1 }}
{{ ok ？ 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div v-bind:id="'list' + id"></div>
```

> <font color=orange>Note：</font>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单（如`Math`和`Date`），访问不到用户定义的全局变量。

---

### 1.2 指令

指令是带有`v-`前缀的特殊特性。指令特性的值预期是单个 JS 表达式（`v-for`例外）。

指令的职责：当表达式的值改变，将其产生的连带影响，响应式地作用于 DOM。

#### 1.2.1 参数

一些指令能接受一个参数，在指令名后以冒号(`:`)表示。

```html
<a v-bind:href="url">...</a>
```

#### 1.2.2 动态参数

v2.6.0 开始，可以用方括号括起来的 JS 表达式作为一个指令的参数：

```html
<a v-on:[eventName]="doSomething">...</a>
```

**对参数表达式的约束：**

1. 回避大写键名。

   ```html
   <!-- 在DOM中使用模板时这段代码会被转换为v-bind:[someattr] -->
   <a v-bind:[someAttr]="value"> ... </a>
   ```

2. 使用没有空格或引号的表达式。

   ```html
   <!-- 这会触发一个编译警告 -->
   <a v-bind:['foo' + bar]="value"> ... </a>
   ```

#### 1.2.3 修饰符

修饰符是以半角句号(`.`)指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

```html
<!-- .prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault() -->
<form v-on:submit.prevent="onSubmit">...</form>
```

---

### 1.3 缩写

对于一些频繁用到的指令来说，使用`v-`前缀会比较繁琐。同时在构建 Vue 管理所有模板的 SPA 时，这个前缀没那么重要。因此 Vue 为`v-bind`和`v-on`这两个最常用的指令提供了简写。

#### 1.3.1 `v-bind`缩写

```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>
<!-- 缩写 -->
<a :href="url">...</a>
```

#### 1.3.2 `v-on`缩写

```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>
<!-- 缩写 -->
<a @click="doSomething">...</a>
```

## 2. 计算属性和侦听器

### 2.1 计算属性

虽然模板内嵌入 JS 表达式是被允许的，但模板中放入太多的复杂逻辑会让模板过重且难以维护。所以对于任何复杂逻辑，都应当使用计算属性。

```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```javascript
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

#### 2.1.1 计算属性缓存 vs 方法

可以通过在表达式中调用方法，达到和上面一样的效果：

```html
<p>Reversed message: "{{ reversedMsg() }}"</p>
```

```javascript
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

虽然2种方式最终结果完全相同，但它们的缓存方式不同：

- 计算属性基于它们的响应式依赖进行缓存，只在相关响应式依赖发生改变时它们才会重新求值。如果相关响应式依赖未发生改变，但触发了重新渲染，不会再次执行计算属性的函数。
- 每当触发重新渲染，调用方法总会再次执行函数。

#### 2.1.2 计算属性 vs 侦听属性

Vue **提供了侦听属性**来观察和响应 Vue 实例上 的数据变动







